var fs = require("fs");

var path = require("path");

var rc = require("./config.js");

var pkg = require("../package.json");

var cache = require("./cache.js");

var transform = require("./transform.js");

var read = require("./utils/read.js");

var exists = require("./utils/exists.js");

var relative = require("./utils/relative.js");

var loaderUtils = require("loader-utils");

function subscribe(subscriber, metadata, context) {
  if (context[subscriber]) {
    context[subscriber](metadata);
  }
}

module.exports = function loader(source, inputSourceMap) {
  var _this = this;

  var filename = this.resourcePath;
  var options = loaderUtils.getOptions(this) || {}; // Use memoryFS (webpack) if available

  fs = this.fs ? this.fs : fs;
  var babelrc = null; // Deprecation handling

  if ("forceEnv" in options) {
    console.warn("The option `forceEnv` has been removed in favor of `envName` in Babel 7.");
  }

  if (typeof options.babelrc === "string") {
    console.warn("The option `babelrc` should not be set to a string anymore in the babel-loader config. " + "Please update your configuration and set `babelrc` to true or false.\n" + "If you want to specify a specific babel config file to inherit config from " + "please use the `extends` option.\nFor more information about this options see " + "https://babeljs.io/docs/core-packages/#options");
  }

  if (options.babelrc !== false) {
    babelrc = options.extends && exists(fs, options.extends) ? options.extends : rc(fs, path.dirname(filename));
  }

  if (babelrc) {
    this.addDependency(babelrc);
  }

  var defaults = {
    filename,
    inputSourceMap: inputSourceMap || undefined,
    sourceRoot: process.cwd(),
    cacheIdentifier: JSON.stringify({
      env: options.envName || process.env.BABEL_ENV || process.env.NODE_ENV || "development",
      options,
      babelrc: babelrc ? read(fs, babelrc) : null,
      "@babel/core": transform.version,
      "@babel/loader": pkg.version
    }),
    metadataSubscribers: []
  };
  options = Object.assign({}, defaults, options);

  if (options.sourceMap === undefined) {
    options.sourceMap = this.sourceMap;
  }

  if (options.sourceFileName === undefined) {
    options.sourceFileName = relative(options.sourceRoot, options.filename);
  }

  var cacheDirectory = options.cacheDirectory;
  var cacheIdentifier = options.cacheIdentifier;
  var metadataSubscribers = options.metadataSubscribers; // Remove loader related options

  delete options.cacheDirectory;
  delete options.cacheIdentifier;
  delete options.metadataSubscribers; // Make the loader async

  var callback = this.async();

  if (cacheDirectory) {
    return cache({
      source,
      options,
      transform,
      cacheDirectory,
      cacheIdentifier
    }, function (err, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          code = _ref.code,
          map = _ref.map,
          metadata = _ref.metadata;

      if (err) return callback(err);
      metadataSubscribers.forEach(function (subscriber) {
        subscribe(subscriber, metadata, _this);
      });
      return callback(null, code, map);
    });
  }

  return transform(source, options, function (err, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        code = _ref2.code,
        map = _ref2.map,
        metadata = _ref2.metadata;

    if (err) return callback(err);
    metadataSubscribers.forEach(function (subscriber) {
      subscribe(subscriber, metadata, _this);
    });
    return callback(null, code, map);
  });
};