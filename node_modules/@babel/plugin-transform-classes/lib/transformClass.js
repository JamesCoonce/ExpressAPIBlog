"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transformClass;

function _helperFunctionName() {
  var data = _interopRequireDefault(require("@babel/helper-function-name"));

  _helperFunctionName = function _helperFunctionName() {
    return data;
  };

  return data;
}

function _helperReplaceSupers() {
  var data = _interopRequireWildcard(require("@babel/helper-replace-supers"));

  _helperReplaceSupers = function _helperReplaceSupers() {
    return data;
  };

  return data;
}

function _helperOptimiseCallExpression() {
  var data = _interopRequireDefault(require("@babel/helper-optimise-call-expression"));

  _helperOptimiseCallExpression = function _helperOptimiseCallExpression() {
    return data;
  };

  return data;
}

function defineMap() {
  var data = _interopRequireWildcard(require("@babel/helper-define-map"));

  defineMap = function defineMap() {
    return data;
  };

  return data;
}

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

var _templateObject = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

function buildConstructor(classRef, constructorBody, node) {
  var func = _core().types.functionDeclaration(_core().types.cloneNode(classRef), [], constructorBody);

  _core().types.inherits(func, node);

  return func;
}

var verifyConstructorVisitor = _core().traverse.visitors.merge([_helperReplaceSupers().environmentVisitor, {
  Super: function Super(path, state) {
    if (state.isDerived) return;
    var node = path.node,
        parentPath = path.parentPath;

    if (parentPath.isCallExpression({
      callee: node
    })) {
      throw path.buildCodeFrameError("super() is only allowed in a derived constructor");
    }
  },
  ThisExpression: function ThisExpression(path, state) {
    if (!state.isDerived) return;
    var node = path.node,
        parentPath = path.parentPath;

    if (parentPath.isMemberExpression({
      object: node
    })) {
      return;
    }

    var assertion = _core().types.callExpression(state.file.addHelper("assertThisInitialized"), [node]);

    path.replaceWith(assertion);
    path.skip();
  }
}]);

function transformClass(path, file, builtinClasses, isLoose) {
  var classState = {
    parent: undefined,
    scope: undefined,
    node: undefined,
    path: undefined,
    file: undefined,
    classId: undefined,
    classRef: undefined,
    superName: undefined,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: undefined,
    constructorBody: undefined,
    userConstructor: undefined,
    userConstructorPath: undefined,
    hasConstructor: false,
    instancePropBody: [],
    instancePropRefs: {},
    staticPropBody: [],
    body: [],
    bareSupers: new Set(),
    superThises: [],
    pushedConstructor: false,
    pushedInherits: false,
    protoAlias: null,
    isLoose: false,
    hasInstanceDescriptors: false,
    hasStaticDescriptors: false,
    instanceMutatorMap: {},
    staticMutatorMap: {}
  };

  var setState = function setState(newState) {
    Object.assign(classState, newState);
  };

  var findThisesVisitor = _core().traverse.visitors.merge([_helperReplaceSupers().environmentVisitor, {
    ThisExpression: function ThisExpression(path) {
      classState.superThises.push(path);
    }
  }]);

  function pushToMap(node, enumerable, kind, scope) {
    if (kind === void 0) {
      kind = "value";
    }

    var mutatorMap;

    if (node.static) {
      setState({
        hasStaticDescriptors: true
      });
      mutatorMap = classState.staticMutatorMap;
    } else {
      setState({
        hasInstanceDescriptors: true
      });
      mutatorMap = classState.instanceMutatorMap;
    }

    var map = defineMap().push(mutatorMap, node, kind, classState.file, scope);

    if (enumerable) {
      map.enumerable = _core().types.booleanLiteral(true);
    }

    return map;
  }

  function maybeCreateConstructor() {
    var hasConstructor = false;
    var paths = classState.path.get("body.body");

    for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _path = _ref;
      hasConstructor = _path.equals("kind", "constructor");
      if (hasConstructor) break;
    }

    if (hasConstructor) return;
    var params, body;

    if (classState.isDerived) {
      var _constructor = _core().template.expression.ast(_templateObject);

      params = _constructor.params;
      body = _constructor.body;
    } else {
      params = [];
      body = _core().types.blockStatement([]);
    }

    classState.path.get("body").unshiftContainer("body", _core().types.classMethod("constructor", _core().types.identifier("constructor"), params, body));
  }

  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();

    if (classState.userConstructor) {
      var constructorBody = classState.constructorBody,
          userConstructor = classState.userConstructor,
          construct = classState.construct;
      constructorBody.body = constructorBody.body.concat(userConstructor.body.body);

      _core().types.inherits(construct, userConstructor);

      _core().types.inherits(constructorBody, userConstructor.body);
    }

    pushDescriptors();
    pushInheritsToBody();
  }

  function pushBody() {
    var classBodyPaths = classState.path.get("body.body");

    for (var _iterator2 = classBodyPaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _path2 = _ref2;
      var node = _path2.node;

      if (_path2.isClassProperty()) {
        throw _path2.buildCodeFrameError("Missing class properties transform.");
      }

      if (node.decorators) {
        throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
      }

      if (_core().types.isClassMethod(node)) {
        var isConstructor = node.kind === "constructor";

        if (isConstructor) {
          _path2.traverse(verifyConstructorVisitor, {
            isDerived: classState.isDerived,
            file: classState.file
          });
        }

        var replaceSupers = new (_helperReplaceSupers().default)({
          methodPath: _path2,
          objectRef: classState.classRef,
          superRef: classState.superName,
          isLoose: classState.isLoose,
          file: classState.file
        });
        replaceSupers.replace();
        var state = {
          returns: [],
          bareSupers: new Set()
        };

        _path2.traverse(_core().traverse.visitors.merge([_helperReplaceSupers().environmentVisitor, {
          ReturnStatement: function ReturnStatement(path, state) {
            if (!path.getFunctionParent().isArrowFunctionExpression()) {
              state.returns.push(path);
            }
          },
          Super: function Super(path, state) {
            var node = path.node,
                parentPath = path.parentPath;

            if (parentPath.isCallExpression({
              callee: node
            })) {
              state.bareSupers.add(parentPath);
            }
          }
        }]), state);

        if (isConstructor) {
          pushConstructor(state, node, _path2);
        } else {
          pushMethod(node, _path2);
        }
      }
    }
  }

  function clearDescriptors() {
    setState({
      hasInstanceDescriptors: false,
      hasStaticDescriptors: false,
      instanceMutatorMap: {},
      staticMutatorMap: {}
    });
  }

  function pushDescriptors() {
    var body = classState.body;
    var instanceProps;
    var staticProps;

    if (classState.hasInstanceDescriptors) {
      instanceProps = defineMap().toClassObject(classState.instanceMutatorMap);
    }

    if (classState.hasStaticDescriptors) {
      staticProps = defineMap().toClassObject(classState.staticMutatorMap);
    }

    if (instanceProps || staticProps) {
      if (instanceProps) {
        instanceProps = defineMap().toComputedObjectFromClass(instanceProps);
      }

      if (staticProps) {
        staticProps = defineMap().toComputedObjectFromClass(staticProps);
      }

      var args = [_core().types.cloneNode(classState.classRef), _core().types.nullLiteral(), _core().types.nullLiteral()];
      if (instanceProps) args[1] = instanceProps;
      if (staticProps) args[2] = staticProps;
      var lastNonNullIndex = 0;

      for (var i = 0; i < args.length; i++) {
        if (!_core().types.isNullLiteral(args[i])) lastNonNullIndex = i;
      }

      args = args.slice(0, lastNonNullIndex + 1);
      body.push(_core().types.expressionStatement(_core().types.callExpression(classState.file.addHelper("createClass"), args)));
    }

    clearDescriptors();
  }

  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    var bareSuperNode = bareSuper.node;
    var call;

    if (classState.isLoose) {
      bareSuperNode.arguments.unshift(_core().types.thisExpression());

      if (bareSuperNode.arguments.length === 2 && _core().types.isSpreadElement(bareSuperNode.arguments[1]) && _core().types.isIdentifier(bareSuperNode.arguments[1].argument, {
        name: "arguments"
      })) {
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = _core().types.memberExpression(_core().types.cloneNode(superRef), _core().types.identifier("apply"));
      } else {
        bareSuperNode.callee = _core().types.memberExpression(_core().types.cloneNode(superRef), _core().types.identifier("call"));
      }

      call = _core().types.logicalExpression("||", bareSuperNode, _core().types.thisExpression());
    } else {
      bareSuperNode = (0, _helperOptimiseCallExpression().default)(_core().types.callExpression(classState.file.addHelper("getPrototypeOf"), [_core().types.cloneNode(classState.classRef)]), _core().types.thisExpression(), bareSuperNode.arguments);
      call = _core().types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [_core().types.thisExpression(), bareSuperNode]);
    }

    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
      if (classState.superThises.length) {
        call = _core().types.assignmentExpression("=", thisRef(), call);
      }

      bareSuper.parentPath.replaceWith(_core().types.returnStatement(call));
    } else {
      bareSuper.replaceWith(_core().types.assignmentExpression("=", thisRef(), call));
    }
  }

  function verifyConstructor() {
    if (!classState.isDerived) return;
    var path = classState.userConstructorPath;
    var body = path.get("body");
    path.traverse(findThisesVisitor);
    var guaranteedSuperBeforeFinish = !!classState.bareSupers.size;

    var _thisRef = function thisRef() {
      var ref = path.scope.generateDeclaredUidIdentifier("this");

      _thisRef = function thisRef() {
        return _core().types.cloneNode(ref);
      };

      return ref;
    };

    for (var _iterator3 = classState.bareSupers, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var bareSuper = _ref3;
      wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

      if (guaranteedSuperBeforeFinish) {
        bareSuper.find(function (parentPath) {
          if (parentPath === path) {
            return true;
          }

          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
            guaranteedSuperBeforeFinish = false;
            return true;
          }
        });
      }
    }

    for (var _iterator4 = classState.superThises, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var thisPath = _ref4;
      var node = thisPath.node,
          parentPath = thisPath.parentPath;

      if (parentPath.isMemberExpression({
        object: node
      })) {
        thisPath.replaceWith(_thisRef());
        continue;
      }

      thisPath.replaceWith(_core().types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
    }

    var wrapReturn;

    if (classState.isLoose) {
      wrapReturn = function wrapReturn(returnArg) {
        var thisExpr = _core().types.callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);

        return returnArg ? _core().types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
      };
    } else {
      wrapReturn = function wrapReturn(returnArg) {
        return _core().types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
      };
    }

    var bodyPaths = body.get("body");

    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
      body.pushContainer("body", _core().types.returnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
    }

    for (var _iterator5 = classState.superReturns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref5 = _i5.value;
      }

      var returnPath = _ref5;
      returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
    }
  }

  function pushMethod(node, path) {
    var scope = path ? path.scope : classState.scope;

    if (node.kind === "method") {
      if (processMethod(node, scope)) return;
    }

    pushToMap(node, false, null, scope);
  }

  function processMethod(node, scope) {
    if (classState.isLoose && !node.decorators) {
      var classRef = classState.classRef;

      if (!node.static) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }

      var methodName = _core().types.memberExpression(_core().types.cloneNode(classRef), node.key, node.computed || _core().types.isLiteral(node.key));

      var func = _core().types.functionExpression(null, node.params, node.body, node.generator, node.async);

      func.returnType = node.returnType;

      var key = _core().types.toComputedKey(node, node.key);

      if (_core().types.isStringLiteral(key)) {
        func = (0, _helperFunctionName().default)({
          node: func,
          id: key,
          scope: scope
        });
      }

      var expr = _core().types.expressionStatement(_core().types.assignmentExpression("=", methodName, func));

      _core().types.inheritsComments(expr, node);

      classState.body.push(expr);
      return true;
    }

    return false;
  }

  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({
        protoAlias: classState.scope.generateUidIdentifier("proto")
      });

      var classProto = _core().types.memberExpression(classState.classRef, _core().types.identifier("prototype"));

      var protoDeclaration = _core().types.variableDeclaration("var", [_core().types.variableDeclarator(classState.protoAlias, classProto)]);

      classState.body.push(protoDeclaration);
    }
  }

  function pushConstructor(replaceSupers, method, path) {
    if (path.scope.hasOwnBinding(classState.classRef.name)) {
      path.scope.rename(classState.classRef.name);
    }

    setState({
      userConstructorPath: path,
      userConstructor: method,
      hasConstructor: true,
      bareSupers: replaceSupers.bareSupers,
      superReturns: replaceSupers.returns
    });
    var construct = classState.construct;

    _core().types.inheritsComments(construct, method);

    construct.params = method.params;

    _core().types.inherits(construct.body, method.body);

    construct.body.directives = method.body.directives;
    pushConstructorToBody();
  }

  function pushConstructorToBody() {
    if (classState.pushedConstructor) return;
    classState.pushedConstructor = true;

    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
      pushDescriptors();
    }

    classState.body.push(classState.construct);
  }

  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    setState({
      pushedInherits: true
    });
    classState.body.push(_core().types.expressionStatement(_core().types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [_core().types.cloneNode(classState.classRef), _core().types.cloneNode(classState.superName)])));
  }

  function setupClosureParamsArgs() {
    var superName = classState.superName;
    var closureParams = [];
    var closureArgs = [];

    if (classState.isDerived) {
      var arg = classState.extendsNative ? _core().types.callExpression(classState.file.addHelper("wrapNativeSuper"), [_core().types.cloneNode(superName)]) : _core().types.cloneNode(superName);
      var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
      closureParams.push(param);
      closureArgs.push(arg);
      setState({
        superName: _core().types.cloneNode(param)
      });
    }

    return {
      closureParams: closureParams,
      closureArgs: closureArgs
    };
  }

  function classTransformer(path, file, builtinClasses, isLoose) {
    setState({
      parent: path.parent,
      scope: path.scope,
      node: path.node,
      path: path,
      file: file,
      isLoose: isLoose
    });
    setState({
      classId: classState.node.id,
      classRef: classState.node.id ? _core().types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: _core().types.blockStatement([])
    });
    setState({
      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
    });
    var classRef = classState.classRef,
        node = classState.node,
        constructorBody = classState.constructorBody;
    setState({
      construct: buildConstructor(classRef, constructorBody, node)
    });
    var body = classState.body;

    var _setupClosureParamsAr = setupClosureParamsArgs(),
        closureParams = _setupClosureParamsAr.closureParams,
        closureArgs = _setupClosureParamsAr.closureArgs;

    buildBody();

    if (!classState.isLoose) {
      constructorBody.body.unshift(_core().types.expressionStatement(_core().types.callExpression(classState.file.addHelper("classCallCheck"), [_core().types.thisExpression(), _core().types.cloneNode(classState.classRef)])));
    }

    body = body.concat(classState.staticPropBody.map(function (fn) {
      return fn(_core().types.cloneNode(classState.classRef));
    }));
    var isStrict = path.isInStrictMode();
    var constructorOnly = classState.classId && body.length === 1;

    if (constructorOnly && !isStrict) {
      for (var _iterator6 = classState.construct.params, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
        var _ref6;

        if (_isArray6) {
          if (_i6 >= _iterator6.length) break;
          _ref6 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done) break;
          _ref6 = _i6.value;
        }

        var param = _ref6;

        if (!_core().types.isIdentifier(param)) {
          constructorOnly = false;
          break;
        }
      }
    }

    var directives = constructorOnly ? body[0].body.directives : [];

    if (!isStrict) {
      directives.push(_core().types.directive(_core().types.directiveLiteral("use strict")));
    }

    if (constructorOnly) {
      return _core().types.toExpression(body[0]);
    }

    body.push(_core().types.returnStatement(_core().types.cloneNode(classState.classRef)));

    var container = _core().types.arrowFunctionExpression(closureParams, _core().types.blockStatement(body, directives));

    return _core().types.callExpression(container, closureArgs);
  }

  return classTransformer(path, file, builtinClasses, isLoose);
}